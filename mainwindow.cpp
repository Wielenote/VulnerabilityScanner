#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <JsonParser.h>
#include <adddevice_dialog.h>
#include <qtreewidget.h>
#include <QTreeWidgetItem>
#include <fstream>
#include <sstream>
#include <future>
#include <thread>
#include <VulnerabilityDatabase.h>
#include <algorithm>

static std::vector<std::string> split(const std::string &s, char delim)
{
    std::vector<std::string> elems;
    std::stringstream ss(s);
    std::string item;
    while (std::getline(ss, item, delim)) {
        elems.push_back(item);
    }
    return elems;
}

void MainWindow::ShowDevices()
{
    ui->listWidget->clear();
    QString path = "/home/wielenote/Documents/devices.json";
    auto file = JsonFile::ReadFile(path);
    auto doc = QJsonDocument::fromJson(file);
    auto doc_object = doc.object();

    auto list_of_devices = doc_object.keys();
    ui->listWidget->addItems(list_of_devices);
}

void InitDatabase(V_Database& database)
{
    auto path = "/home/wielenote/build-QueryTest-Desktop_Qt_6_5_3_GCC_64bit-Debug/script_result_ZOS.txt";
    std::ifstream stream(path);
    string line;
    getline(stream,line);
    QString folder_path = "/home/wielenote/build-QueryTest-Desktop_Qt_6_5_3_GCC_64bit-Debug/vulnerabilities/";
    if(stream)
    {
        while(getline(stream,line))
        {
            auto sub_strs = split(line, ' ');
            if (sub_strs[0] == "acl")
            {
                qDebug() << "123";
            }
            int count = 0;
            int index_of_file = 0;
            bool notEmpty = false;
            do{
                ++index_of_file;
                auto file_path = folder_path+QString::fromStdString(sub_strs[0])+ "-" + QString::number(index_of_file) +".json";
                auto a = JsonFile(file_path,sub_strs[0]);
                auto val = a.GetVulnerabilities();

                if  (count == 0)
                    count = a.GetCountFiles();

                auto tmp = database.InsertVulnerability(val, sub_strs[0]);
                if (notEmpty == true)
                    continue;
                notEmpty = tmp;

            }while(index_of_file < count);
            if(notEmpty)
                database.SortVulners(sub_strs[0]);
        }
    }
}




MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    database = V_Database();
    ui->setupUi(this);
    ui->tabWidget->setCurrentIndex(0);
    ui->label_Warning->setVisible(false);
    ShowDevices();
    qDebug() << "start initialazing database ...";
    InitDatabase(database);
    qDebug() << "end of initialize!";
}

MainWindow::~MainWindow()
{
    delete ui;
}



void MainWindow::onResult(QNetworkReply *reply)
{
    auto er = reply->error();
    if(er == QNetworkReply::NoError)
    {
        QJsonDocument document = QJsonDocument::fromJson(reply->readAll());
        auto Object = document.object().value("cves");
        auto array = Object.toArray();
        auto currentObject = array.at(0).toObject();
        for(const auto& item : currentObject.keys())
        {

            qDebug() << item <<'-' << currentObject.value(item).toVariant().toString();
        }
    }
    reply->deleteLater();
}

void MainWindow::on_add_button_clicked()
{
    AddDevice_dialog dialog(this);
    this->hide();
    dialog.exec();
}




void GetVulnerabilities(string path, string package_name)
{

}
//const char*
std::string exec(string cmd) {
    char buffer[128];
    std::string result = "";
    FILE* pipe = popen(cmd.data(), "r");
    if (!pipe) throw std::runtime_error("popen() failed!");
    {
        while (fgets(buffer, sizeof buffer, pipe) != NULL)
            result += buffer;
    }

    pclose(pipe);
    return result;
}

static bool IsVulnerable(const string& device_version,const string& vulner_version)
{
    stringstream ss;
    ss << "dpkg --compare-versions \"" << device_version << "\" \"ge\" \"" << vulner_version << "\"; echo $?";
    return exec(ss.str())[0] == '1'; // 1 - false & 0 - true
}

void SetVulnerabilityToTreeObject(const Vulnerability& vulnerability,QTreeWidgetItem *item)
{
    QTreeWidgetItem *cve_root = new QTreeWidgetItem(); // узел - текст:cve-id
    QTreeWidgetItem *cve_info_root_cvss = new QTreeWidgetItem(); // cvss
    QTreeWidgetItem *cve_info_root_status = new QTreeWidgetItem(); //status
    QTreeWidgetItem *cve_info_root_description = new QTreeWidgetItem();
    QTreeWidgetItem *cve_info_root_description_value = new QTreeWidgetItem();

    cve_root->setText(0, QString::fromStdString(vulnerability.GetCVE_ID()));

    std::stringstream ss;
    ss << std::fixed << std::setprecision(2) << vulnerability.GetCVSS();
    cve_info_root_cvss->setText(0, "CVSS : " + QString::fromStdString(ss.str()));
    cve_info_root_status->setText(0,"Status : " + QString::fromStdString(vulnerability.GetStatus()));
    cve_info_root_description->setText(0,"Description");
    cve_info_root_description_value->setText(0, QString::fromStdString(vulnerability.GetDescription()));

    cve_info_root_description->addChild(cve_info_root_description_value);
    cve_root->addChildren({cve_info_root_cvss, cve_info_root_status, cve_info_root_description});

    item->addChild(cve_root);
}

void SetCVEToTreeObject(const Vulnerability& vulnerability,QTreeWidgetItem *item)
{
    QTreeWidgetItem *cve_root = new QTreeWidgetItem(); // узел - текст:cve-id
    QTreeWidgetItem *cve_info_root_cvss = new QTreeWidgetItem(); // cvss
    QTreeWidgetItem *cve_info_root_status = new QTreeWidgetItem(); //status
    QTreeWidgetItem *cve_info_root_description = new QTreeWidgetItem();
    QTreeWidgetItem *cve_info_root_description_value = new QTreeWidgetItem();
    QTreeWidgetItem *cve_info_root_package_name = new QTreeWidgetItem();

    cve_root->setText(0, QString::fromStdString(vulnerability.GetCVE_ID()));
    cve_info_root_package_name->setText(0,QString::fromStdString(vulnerability.GetPackageName()));
    std::stringstream ss;
    ss << std::fixed << std::setprecision(2) << vulnerability.GetCVSS();
    cve_info_root_cvss->setText(0, "CVSS : " + QString::fromStdString(ss.str()));
    cve_info_root_status->setText(0,"Status : " + QString::fromStdString(vulnerability.GetStatus()));
    cve_info_root_description->setText(0,"Description");
    cve_info_root_description_value->setText(0, QString::fromStdString(vulnerability.GetDescription()));

    cve_info_root_description->addChild(cve_info_root_description_value);
    cve_root->addChildren({cve_info_root_package_name, cve_info_root_cvss, cve_info_root_status, cve_info_root_description});

    item->addChild(cve_root);
}

void MainWindow::on_tabWidget_currentChanged(int index)
{
    if (index == 2)
    {
            //ui->label_Warning->setVisible(true);
        auto a = IsVulnerable("0.6.55-0ubuntu12~20.04.5", "0.6.55-0ubuntu12~20.04.5");
        auto b = IsVulnerable("1.1", "1.2.1");
        qDebug() << b;
    }
    if(index == 1)
    {

        for(const auto& package : database.GetDatabase())
        {
            QTreeWidgetItem *res = new QTreeWidgetItem();// узел уязвимости- ребенок для главного узла

            res->setText(0, QString::fromStdString(package.first));
            for(const auto& vulnerability : package.second)
            {
                SetVulnerabilityToTreeObject(vulnerability, res);
            }

            //packge_root->addChild(res);
            ui->treeWidget->addTopLevelItem(res);
        }





//        auto path = "/home/wielenote/build-QueryTest-Desktop_Qt_6_5_3_GCC_64bit-Debug/script_result_ZOS.txt";
//        std::ifstream stream(path);
//        string line;
//        getline(stream,line);
//        QString folder_path = "/home/wielenote/build-QueryTest-Desktop_Qt_6_5_3_GCC_64bit-Debug/vulnerabilities/";
//        if (stream)
//        {
//            while(getline(stream,line))
//            {
//                auto sub_strs = split(line, ' ');
//                if (sub_strs[0] == "zip")
//                {
//                    qDebug() << "123";
//                }
//                ui->treeWidget->setColumnCount(1);

//                QTreeWidgetItem *res = new QTreeWidgetItem();
//                int count = 0;
//                int index_of_file = 0;
//                do {
//                    ++index_of_file;
//                    auto file_path = folder_path+QString::fromStdString(sub_strs[0])+ "-" + QString::number(index_of_file) +".json";
//                    auto a = JsonFile(file_path,sub_strs[0]);
//                    auto val = a.GetVulnerabilities();
//                    if  (count == 0)
//                        count = a.GetCountFiles();
//                    if (val.size() == 0)
//                        break;


//                    for (const auto& item : val)
//                    {
//                        QTreeWidgetItem *cve_root = new QTreeWidgetItem();
//                        QTreeWidgetItem *cve_info_root1 = new QTreeWidgetItem();
//                        QTreeWidgetItem *cve_info_root2 = new QTreeWidgetItem();
//                        QTreeWidgetItem *cve_info_root_description = new QTreeWidgetItem();
//                        QTreeWidgetItem *cve_info_root_description_value = new QTreeWidgetItem();
//                        std::stringstream ss;
//                        ss << std::fixed << std::setprecision(2) << item.GetCVSS();


//                        cve_root->setText(0, QString::fromStdString(item.GetCVE_ID()));




//                        if((item.GetStatus() == "released" && IsVulnerable(sub_strs[1], item.GetReleasedVersion())) ||
//                            item.GetStatus() != "released" )
//                            cve_root->setForeground(0,QBrush(Qt::red));





//                        auto status = QString::fromStdString(item.GetStatus());
//                        cve_info_root1->setText(0, "Status: " + status);
//                        cve_info_root2->setText(0, "CVSS3: " + QString::fromStdString(ss.str()));
//                        cve_info_root_description->setText(0, "Description");
//                        cve_info_root_description_value->setText(0, QString::fromStdString(item.GetDescription()));
//                        cve_root->addChild(cve_info_root1);
//                        cve_root->addChild(cve_info_root2);

//                        cve_info_root_description->addChild(cve_info_root_description_value);
//                        cve_root->addChild(cve_info_root_description);

//                        if (status != "Unknown")
//                            res->addChild(cve_root);

//                    }
//                } while(index_of_file < count);

//                if(res->childCount() != 0)
//                {
//                    QTreeWidgetItem *packge_root = new QTreeWidgetItem(ui->treeWidget);
//                    packge_root->insertChildren(0,res->takeChildren());
//                    ui->treeWidget->addTopLevelItem(packge_root);
//                    packge_root->setText(0, QString::fromStdString(sub_strs[0]));
//                }
//            }


//        }

    }
    else
    {
        ui->treeWidget->clear();
    }
}

bool RunScript(Ui::MainWindow* ui)
{

    stringstream ss;
    ss << "/home/wielenote/CourseProject/VulnerabilityScanner/update_dbv.sh"; // ./check_installed_packages.sh
    qDebug() << QString::fromStdString(ss.str());
    system(ss.str().c_str());
    return true;
}
void MainWindow::on_pushButton_clicked()
{
    //int total = stoi(exec("wc -l /home/wielenote/build-QueryTest-Desktop_Qt_6_5_3_GCC_64bit-Debug/script_result_ZOS.txt")) - 1;
    //ui->progressBar->setMaximum(total);


    ui->label_Warning->setVisible(true);


    future<bool> ft = async(RunScript, ui);
    ft.wait();
    if (ft.get())
    {
        ui->label_Warning->setVisible(false);
    }
    //ui->label_Warning->setVisible(false);
    auto a = 0;
}


void MainWindow::on_scan_button_clicked()
{
    QString path = "/home/wielenote/Documents/devices.json";
    auto file = JsonFile::ReadFile(path);
    auto doc = QJsonDocument::fromJson(file);
    auto doc_object = doc.object();
    auto name = ui->listWidget->currentItem()->text();
    auto device = doc_object.value(name).toObject();
    //ui->label_Warning->setVisible(!ui->label_Warning->isVisible());
    stringstream ss;
    ss << "/home/wielenote/CourseProject/VulnerabilityScanner/check_installed_packages.sh " << device.value("password").toVariant().toString().toStdString()
       << " " << device.value("login").toVariant().toString().toStdString() << " " <<
        device.value("ip_adress").toVariant().toString().toStdString();// ./check_installed_packages.sh
    qDebug() << QString::fromStdString(ss.str());
    system(ss.str().c_str());
}




void MainWindow::on_delete_device_button_clicked()
{
    string path = "/home/wielenote/Documents/devices.json";
    auto file = JsonFile::std_ReadFile(path);
    auto object = QJsonDocument::fromJson(file).object();
    auto it = object.find(ui->listWidget->currentItem()->text());
    object.erase(it);
    QJsonDocument res;
    res.setObject(object);
    JsonFile::WriteFile("/home/wielenote/Documents/devices.json", res.toJson());
    ShowDevices();
}

template <typename RandIt>
pair<RandIt, RandIt> FindStartsWith(RandIt beg, RandIt end, string prefix)
{
    size_t prefix_size = prefix.size();
    auto lower = lower_bound(beg, end, prefix, [prefix_size] (decltype(*beg) lhs, const string rhs){
        return lhs.first.substr(0,prefix_size) < rhs;
    });
    auto upper = upper_bound(beg, end, prefix, [prefix_size] (const string lhs, decltype(*beg) rhs){
        return rhs.first.substr(0,prefix_size) > lhs;
    });
    auto iterators =  make_pair(lower, upper);
    return iterators;
}


void MainWindow::on_package_search_radioButton_clicked()
{

}


void MainWindow::on_package_search_radioButton_pressed()
{
    if (ui->package_search_radioButton->isChecked())
        return;
    ui->package_search_radioButton->setChecked(true);
    ui->search_lineEdit->setText("");
    on_search_lineEdit_textChanged("");
}


void MainWindow::on_cve_search_radioButton_pressed()
{
    if(ui->cve_search_radioButton->isChecked())
        return;
    ui->cve_search_radioButton->setChecked(true);
    ui->search_lineEdit->setText("");
    on_search_lineEdit_textChanged("");
}


void MainWindow::on_search_lineEdit_textChanged(const QString &arg1)
{
    ui->treeWidget->clear();
    auto base = database.GetDatabase();

    auto range_begin = base.begin();
    auto range_end = base.end();
    auto prefix = arg1.toStdString();
    if (ui->cve_search_radioButton->isChecked())
    {
        auto cve = database.GetCVEtoPackage();
        auto iterators = FindStartsWith(cve.begin(),cve.end(), prefix);
        auto db = database.GetDatabase();
        for(auto it = iterators.first; it != iterators.second; ++it)
        {
            QTreeWidgetItem *res = new QTreeWidgetItem();// узел уязвимости- ребенок для главного узла

            res->setText(0, QString::fromStdString(it->first));

            //            for(const auto& vulnerability : database.data[it->second])
            //            {
            //                SetVulnerabilityToTreeObject(vulnerability, res);
            //            }
            SetCVEToTreeObject(it->second, res);
            //packge_root->addChild(res);
            ui->treeWidget->addTopLevelItem(res);
        }
    }
    else {

        //    size_t prefix_size = prefix.size();
        //    auto lower = lower_bound(range_begin, range_end, prefix, [prefix_size] (decltype(*range_begin) lhs, const string rhs){
        //        return lhs.first.substr(0,prefix_size) < rhs;
        //    });
        //    auto upper = upper_bound(range_begin, range_end, prefix, [prefix_size] (const string lhs, decltype(*range_begin) rhs){
        //        return rhs.first.substr(0,prefix_size) > lhs;
        //    });
        auto iterators =  FindStartsWith(range_begin,range_end, prefix);//make_pair(lower, upper);


        for(auto it = iterators.first; it != iterators.second; ++it)
        {
            QTreeWidgetItem *res = new QTreeWidgetItem();// узел уязвимости- ребенок для главного узла

            res->setText(0, QString::fromStdString(it->first));

            for(const auto& vulnerability : it->second)
            {
                SetVulnerabilityToTreeObject(vulnerability, res);
            }

            //packge_root->addChild(res);
            ui->treeWidget->addTopLevelItem(res);
        }
    }
}

